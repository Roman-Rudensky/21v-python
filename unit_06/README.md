# 21v-python

# Errors
Существует (как минимум) два различимых вида ошибок: синтаксические ошибки (syntax errors) и исключения (exceptions).

# Синтаксические ошибки
```
while True print 'Hello world'
  File "<stdin>", line 1, in ?
    while True print 'Hello world'
                   ^
SyntaxError: invalid syntax
```

Даже, если ваша программа работает правильно, неверные данные и ошибки ввода могут привести к непредсказуемым результатам. Поэтому мы познакомимся с перехватом ошибок и тем, что мы с ними после перехвата можем сделать. 

```
import sys
C = float(sys.argv[1])

if C < -273.15:
    print '%g degrees Celsius is non-physical!' % C
    print 'The Fahrenheit temperature will not be computed.'
else:
    F = 9.0/5*C + 32
    print F
print 'end of program'
```

Представим, что в нашей программе мы забыли передать аргумент:
```
c2f.py Traceback (most recent call last):
File"c2f.py", line 2, in
C = float(sys.argv[1])
IndexError: list index out of range
```
Python прервал выполнение программы, показал что ошибка находится во второй строке и указал на тип ошибки — IndexError и краткое объяснение что не так. Из этой информации, просмотрев код программы, можно сделать вывод, что индекс 1 выходит за пределы списка (index out of range). А это и правильно, ведь в списке sys.argv только нулевой элемент, название программы. Значит есть всего один возможный индекс 0.

как эту ошибку обработать? Ведь нам не хотелось бы, чтобы программа завершалась, когда мы того не хотим. Первое, что приходит на ум —  предварительно проверять длину списка c2f1.py:
```
if len(sys.argv) < 2:
    print 'You failed to provide Celsius degrees as input '\
        'on  the  command  line!'
    sys.exit(1)   #  прекращаем ввиду ошибки
F = 9.0*C/5 + 32
print '%gC is %.1fF' % (C, F)
```
Для преднамеренного прекращения программы используется функция exit модуля sys. В случае прекращения программы без ошибок функции передается 0, в случае наличия ошибки любое отличное от нуля значение (например, 1). Но это решение для такого элегантного языка как Python весьма неповоротливо и громоздко, в нем существует гораздо более приятная конструкция.

# Исключения

```
def fetcher(obj, index):
    return obj[index]

x = 'spam'
fetcher(x, 3)           # Like x[3] 'm'

fetcher(x, 4)

Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "<stdin>", line 2, in fetcher
IndexError: string index out of range

```
Исключения представлены различными типами и тип исключения выводится в качестве части сообщения: в примере это типы ZeroDivisionError, NameError и TypeError. Часть строки, описывающая тип исключения — это имя произошедшего встроенного исключения. Такое утверждение истинно для всех встроенных исключений, но не обязано быть истинным для исключений, определённых пользователем (однако, само соглашение — довольно полезное). 

Имена стандартных исключений это встроенные идентификаторы (не ключевые слова).

Оставшаяся часть строки описывает детали произошедшего на основе типа исключения, которое было его причиной.

Предшествующая часть сообщения об ошибке показывает контекст, где произошло исключение, в форме стека вызовов. В общем случае она содержит стек, состоящий из списка строк исходного кода; тем не менее, в неё не войдут строки, прочитанные из стандартного ввода.


# Обработка исключений

Обработка исключений поддерживается в Python посредством операторов try, except, else, finally, raise, образующих блок обработки исключения. В общем случае блок выглядит следующим образом:
```
try:
    # Здесь код, который может вызвать исключение
    raise Exception("message")  # Exception, это один из стандартных типов исключения (всего лишь класс),
    # может использоваться любой другой, в том числе свой

except (Тип исключения1, Тип исключения2, …) as Переменная:
    # Код в блоке выполняется, если тип исключения совпадает с одним из типов
    # (Тип исключения1, Тип исключения2, …) или является наследником одного
    # из этих типов.
    # Полученное исключение доступно в необязательной Переменной.

except (Тип исключения3, Тип исключения4, …) as Переменная:
    # Количество блоков except не ограничено
    raise  # Сгенерировать исключение "поверх" полученного; без параметров - повторно сгенерировать полученное

except:
    # Будет выполнено при любом исключении, не обработанном типизированными блоками except

else:
    # Код блока выполняется, если не было поймано исключений.

finally:
    # Будет исполнено в любом случае, возможно после соответствующего
    # блока except или else
```
Совместное использование else, except и finally стало возможно только начиная с Python 2.5. Информация о текущем исключении всегда доступна через sys.exc_info(). Кроме значения исключения, Python также сохраняет состояние стека вплоть до точки возбуждения исключения — так называемый traceback.

В отличие от компилируемых языков программирования, в Python использование исключения не приводит к значительным накладным расходам (а зачастую даже позволяет ускорить исполнение программ) и очень широко используется. Исключения согласуются с философией Python (10-й пункт «дзена Python» — «Ошибки никогда не должны умалчиваться») и являются одним из средств поддержки «утиной типизации».

Иногда вместо явной обработки исключений удобнее использовать блок with (доступен, начиная с Python 2.5).

Исключения свидетельствуют об ошибках и прерывают нормальный ход выполнения программы. 

Исключения возбуждаются с помощью инструкции raise. В общем случае инструкция raise имеет следующий вид:

raise Exception([value]), где Exception – тип исключения, а value – необязательное значение с дополнительной информацией об исключении.

```
Например:
raise RuntimeError(“Неустранимая ошибка”)

```

# Перехватить исключение можно с помощью инструкций try и except:

```
try:
    fetcher(x, 4)
except IndexError:
    print 'got exception' # got exception

def catcher():
    try:
        fetcher(x, 4)
    except IndexError:
        print 'got exception'
    print 'continuing'

catcher() # got exception continuing
```

Если инструкция raise используется без дополнительных параметров, она повторно возбуждает последнее исключение (однако такой прием работает только в процессе обработки возникшего исключения).

Рассмотрим простейший пример: открытие файла. Если всё нормально — open(filename, 'r') возвращает объект этого самого файла 
Если файл не может быть открыт — выбрасывается исключение:
```
try:
    f = open(filename, 'r')
    try:
        print(f.read())
    finally:
        f.close()
except OSError as ex:
    print("Cannot process file", filename, ": Error is", ex)
```
Обратите внимание: файл нужно не только открыть но и закрыть после использования. Исключение может выбросить open (например, если файла нет на диске или нет прав на его чтение).
```
Traceback (most recent call last):
  File "fopen.py", line 5, in <module>
    f = open (filename, 'r')
IOError: [Errno 2] No such file or directory: 'file.txt'
</module>

```
Если файл открыт — читаем его через f.read(). Этот вызов тоже может выбросить исключение, но файл закрывать всё равно нужно. Поэтому необходим блок finally: f.close() должен быть вызван даже если f.read() сломался.

Исключения из обоих мест попадут в except OSError, где можно будет что-то сделать с ошибкой.
Питон делает явный выбор в пользу исключений перед возвратом кода ошибки в своём ядре и стандартной библиотеке c2f2.py.
```
import sys
try:
    C = float(sys.argv[1])
except:
    print 'You failed to provide Celsius degrees as input '\
          'on the command line!'
    sys.exit(1)

F = 9.0*C/5 + 32
print '%gC is %.1fF' % (C, F)
```
Теперь, если мы не передадим аргументов, то найти sys.argv[1] невозможно, значит наша кампания потерпела неудачу, возникло исключение и мы отправляемся в блок except. Если же передать аргумент, то выполняется только блок try. Проверим:
```
c2f2.py
You failed to provide Celsius degrees as input on the command line!
c2f2.py 21
21C is 69.8F
```
## Особые исключения

Возвращаясь к выражению C = float(sys.argv[1]) можно сказать, что вообще здесь видны две чаще всего встречающиеся ошибки: первая, которую мы рассмотрели — отсутствие значения аргумента, вторая — в качестве аргумента вводится строка, которая не может быть конвертирована в float. Python определяет обе эти ошибки и называет их определенными именами: в первом случае это IndexError, во втором случае ValueError. В программе выше мы переходим в общий блок except независимо от того, что происходит неправильно в блоке try. Например, мы не пропустили значение переменной при вызове, но записали его в неверной форме (21С), результат тот же, что и раньше:

c2f2.py 21C
You failed to provide Celsius degrees as input on the command line!

В Python есть удобная возможность разделять инструкции для ошибок различного рода c2f3.py:
```
import sys
try:
    C = float(sys.argv[1])
except IndexError:
    print 'Celsius degrees must be supplied on the command line'
    sys.exit(1)
except ValueError:
    print 'Celsius degrees must be a pure number, '\
          'not  "%s"' % sys.argv[1]
    sys.exit(1)

F = 9.0*C/5 + 32
print '%gC is %.1fF' % (C, F)
```
Теперь в зависимости от ошибки совершенной пользователем, мы и сами можем сказать пользователю, что он сделал не так и как это исправить.

Возбуждение исключений полезно, когда мы хотим уточнить какую-то ошибку, например понятную нам из физического смысла или каких-то других соображений. Пусть для ввода температуры и подойдет аргумент в виде числа, но мы помним про абсолютный ноль и предостерегаем пользователя c2f4.py:
```
def read_C():
    try:
        C = float(sys.argv[1])
    except IndexError:
        raise IndexError('Celsius degrees must be supplied on the command line')
    except  ValueError:
        raise ValueError('Celsius  degrees must be a pure number, '\
                         'not "%s"' % sys.argv[1])
    if C < -273.15:
        raise ValueError('C=%g is a non-physical value!' % C)
    return C
```
Далее имеются две возможности использовать функцию read_C(). Простой:
```
C = read_C()
```
Неправильный ввод приведет к:
```
c2f4.py
Traceback (most recent call last):
File "c2f.py", line 5, in ?
raise IndexError
IndexError: Celsius degrees must be supplied on the command line.
```
Но стоит помнить, что вашей программой можете пользоваться не только вы и всегда надо стремиться скрывать лишнюю ненужную информацию. Для людей, незнакомых с Python, возникающие на экране слова Traceback, raise, IndexError могут вызвать недоумение. Самая важная информация для человека, работающего с вашей программой расположена в самом конце. Существует возможность выводить только эту строку. В этом случае функцию мы вызываем так c2f5.py:
```
try:
    C = read_C()
except Exception, e:
    print e
    sys.exit(1)
```
Exception это имена всех возможных исключений, e — сообщение исключения. В нашем случае у нас в функции записаны два типа исключений, поэтому:
```
try:
    C = read_C()
except  (ValueError, IndexError), e:
    print e
    sys.exit(1)
```
После блока определения функции и блока try-except пишем блок вычислений и проверяем программу:
```
import sys

def read_C():
    try:
        C = float(sys.argv[1])
    except IndexError:
        raise IndexError\
        ('Celsius degrees must be supplied on the command line')
    except ValueError:
        raise ValueError\
        ('Celsius degrees must be a pure number, '\
         'not "%s"' % sys.argv[1])
    # C is read correctly as a number, but can have wrong value:
    if C < -273.15:
        raise ValueError('C=%g is a non-physical value!' % C)
    return C

try:
    C = read_C()
except (IndexError, ValueError), e:
    print e
    sys.exit(1)
    
F = 9.0*C/5 + 32
print '%gC is %.1fF' % (C, F)

c2f5.py
Celsius degrees must be supplied on the command line
c2f.py 21C
Celsius degrees must be a pure number, not "21C"
c2f.py -500
C=-500 is a non-physical value!
c2f.py 21
21C is 69.8F
```
наша программа теперь не только обрабатывает получаемые данные и выдает ответ, но может работать и с неверными данными, определяя ошибку и выдавая информативное сообщение без лишней раздражающей информации.


# Типы исключений
```
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
  ```
- Самый базовый класс — BaseException. Он и его простые потомки (SystemExit, KeyboardInterrupt,GeneratorExit) не предназначены для перехвата обыкновенным программистом — только Питон и редкие библиотеки должны работать с этими типами. Нарушение правила ведет, например, к тому что программу невозможно корректно завершить.

Использование индекса, выходящего за пределы списка, приводит к ошибке IndexError:
```
>>> data = [1.0/i for i in range(1,10)]
>>> data[9]
...
IndexError: list index out of range
```
Некоторые языки программирования (например, Fortran, C, C++ и Perl) позволяют индексацию вне интервала, что может быть иногда удобным, но делает сложным поиск скрытых ошибок. Python всегда останавливает программу, когда встречает неправильный индекс.

В случае, если содержимое строки не представляет собой только число, конвертирование заканчивается неудачей и ошибкой ValueError:
```
>>> C = float('21 C')
...
ValueError: invalid literal for float(): 21 C
```
В случае, если вызывается переменная, которой не задано значение, возникает ошибка NameError:
```
>>> print a
...
NameError: name 'a' is not defined
```
Деление на ноль:
```
>>> 3.0/0
...
ZeroDivisionError: float division
```
В случае, если вы ошибаетесь в написании ключевых слов языка, возникает SyntaxError:
```
>>> forr d in data:
...
    forr d in data:
         ^
SyntaxError: invalid syntax
```
Если мы захотим перемножить число на строку:
```
>>> 'a  string'*3.14
...
TypeError: can’t multiply sequence by non-int of type 'float'
```
Исключение TypeError возникает, поскольку объекты таких типов не могут быть перемножены (str и float). Но, вообще говоря, это не значит что число и строка не могут быть перемножены.

Перемножение возможно, если число целое (int). Под операцией умножения здесь понимается повторение строки указанное число раз. Это же правило действует и на списки:
```
>>> '--'*10     #  десять двойных дефисов = 20 дефисов
'--------------------'
>>> n  = 4
>>> [1, 2, 3]*n
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
>>> [0]*n
[0, 0, 0, 0]

```

Также не нужно перехватывать все исключения:
```
try:
    ...
except:
    ...
```
работает как
```
try:
    ...
except BaseException:
    ...
```
# используем операторы try и except, чтобы корректно и красиво завершить скрипт

```
'''функция диалога.
Первым аргументом принимаем ответ пользователя,
вторым - выдаём сообщение при неверном вводе'''

def answer(prompt, choice='Только Yes или no!'):
        while True:
                result = raw_input(prompt)
                if result in ('y', 'Y', 'yes', 'Yes'):
                        print '\nВы выбрали "YES" - заканчиваем\n'
                        '''тут можно использовать оператор break вместо return
                        так же и в ответе No'''
                        return False

                elif result in ('n', 'N', 'no', 'No'):
                        print "\nВы выбрали NO - Я продолжаю работу...\n"

                        print_menu()
                        return True
                else:

                        print(choice)
```

- при Ctrl+C (KeyboardInterrupt - SIGINT)
- или Ctrl+D (EOFError - SIGQUIT) команда

```
elif menu_choice == '7':
    try:
        if  (answer("\nВы уверены, что хотите закончить работу? ('y' или 'n', Ctrl+C для выхода) ")==False):
            break
    except (KeyboardInterrupt, EOFError):
        exit('\nВыход\n')
```

# Проиерка обязательных параметров

```
first_name = input("Имя сотрудника: ")
#validate
while first_name == '':
    print('\n Имя сотрудника required.  Try again.')
    first_name = input("Имя сотрудника: ")
last_name = input("Фамилия сотрудника: ")
#validate
while last_name == '':
    print('\n Фамилия сотрудника required.  Try again.')
    last_name = input("Фамилия сотрудника: ")

```

# Проверка допустимых значений параметров

```
ID_valid = False

      ID = input("Идентификатор сотрудника: ")

      while ID_valid == False:

          try:
              ID = float(ID)
              if ID > 0:
                  ID_valid = True
              else:
                  print("\nID должен быть > 0.  Пробуем еще.")
                  ID = input("Идентификатор сотрудника: ")
          except ValueError:
              print("\nID должен быть числом.  Пробуем еще..")
              ID = input("Идентификатор сотрудника:: ")
```

- Всё, что может быть нужно программисту — это Exception и унаследованные от него классы.

лучше ловить как можно более конкретные классы исключений
```
import os

filename = 'file.txt'
try:
    f = open (filename, 'r')
    try:
        print f.read()
    finally:
        f.close()
except (os.error, IOError) as ex:
    print "Cannot process file", filename, ": Error is", ex
```
нструкция finally служит для реализации завершающих действий, сопутствующих операциям, выполняемым в блоке try. Например:

```

try:
    # Выполнить некоторые действия

finally:

def print_staff():
    try:
        n = 0
        for emp in mystaff.employee_list:
            n += 1
            print(emp)

        if n==0 :
            raise MyError(2)
    except MyError as e:
        print '\nНет данных о сотрудниках :', e.value
    else:
        print  'Хранилище содержит ', n, ' строк'
    finally:
        print  'Дата проверки состояния записей ', datetime.now()

```
Блок finally не используется для обработки ошибок. Он используется для реализации действий, которые должны выполняться всегда, независимо от того, возникла ошибка или нет. Если в блоке try исключений не возникло, блок finally будет выполнен сразу же вcлед за ним. Если возникло исключение, управление сначала будет передано первой инструкции в блоке finally, а затем это исключение будет возбуждено повторно, чтобы обеспечить возможность его обработки в другом обработчике.

```
def fetcher(obj, index):
    return obj[index]

x = 'spam'
fetcher(x, 3)           # Like x[3] 'm'

try:
    fetcher(x, 3)
finally:
    print 'after fetch'


fetcher(x, 3)
print 'after fetch'

# KeyboardInterrupt.

while True:
    try:
        x = int(input("Введите, пожалуйста, число: "))
        break
    except ValueError:
        print("Ой!  Это некорректное число.  Попробуйте ещё раз...")
```

# Оператор try работает следующим образом:

- В начале исполняется блок try (операторы между ключевыми словами try и except).

- Если при этом не появляется исключений, блок except не выполняется и оператор try заканчивает работу.

- Если во время выполнения блока try было возбуждено какое-либо исключение, оставшаяся часть блока не выполняется.

- Затем, если тип этого исключения совпадает с исключением, указанным после ключевого слова except, выполняется блок except, а по его завершению выполнение продолжается сразу после оператора try-except.

- Если порождается исключение, не совпадающее по типу с указанным в блоке except — оно передаётся внешним операторам try; 

- если ни одного обработчика не найдено, исключение считается необработанным (unhandled exception), и выполнение полностью останавливается и выводится сообщение.

# Оператор try может иметь более одного блока except
```
except (RuntimeError, TypeError, NameError):
    pass

```
# необязательный блок else
```
def print_staff():
    try:
        n = 0
        for emp in mystaff.employee_list:
            n += 1
            print(emp)

        if n==0 :
            raise MyError(2)
    except MyError as e:
        print '\nНет данных о сотрудниках :', e.value
    else:
        print  'Хранилище содержит ', n, ' строк'

```

# Семейство OSError

До Python 3.3 существовало много разных типов таких исключений: os.error, socket.error, IOError,WindowsError, select.error и т.д.
Это приводило к тому, что приходилось указывать несколько типов обрабатываемых исключений одновременно:

```
try:
    do_something()
except (os.error, IOError) as ex:
    pass
```
исключения операционной системы часто никак не проявляют себя при разработке.

Проблема решена в PEP 3151: пишите OSError и не ошибетесь (прочие имена оставлены для обратной совместимости и облегчения портирования кода на новую версию).

# У OSError есть атрибут errno, который содержит код ошибки.

Открываем файл, получаем OSError в ответ. Раньше мы должны были анализировать ex.errno чтобы понять, отчего произошла ошибка: может файла нет на диске, а может нет прав на запись — это разные коды ошибок (ENOENT если файла нет и EACCES или EPERM если нет прав).
Приходилось строить конструкцию вроде следующей:

```
try:
    f = open(filename)
except OSError as ex:
    if ex.errno == errno.ENOENT:
       handle_file_not_found(filename)
    elif ex.errno in (errno.EACCES, errno.EPERM):
       handle_no_perm(filename)
    else:
       raise  # обязательно выбрасывать не обработанные коды ошибки
```
Теперь иерархия расширилась. Полный список наследников OSError:
```
OSError
 +-- BlockingIOError
 +-- ChildProcessError
 +-- ConnectionError
 |    +-- BrokenPipeError
 |    +-- ConnectionAbortedError
 |    +-- ConnectionRefusedError
 |    +-- ConnectionResetError
 +-- FileExistsError
 +-- FileNotFoundError
 +-- InterruptedError
 +-- IsADirectoryError
 +-- NotADirectoryError
 +-- PermissionError
 +-- ProcessLookupError
 +-- TimeoutError
```
Наш пример можем переписать как:
```
try:
    f = open(filename)
except FileNotFound as ex:
    handle_file_not_found(filename)
except PermissionError as ex:
    handle_no_perm(filename)
```

# Python. Модули и пакеты
Программное обеспечение (приложение или библиотека) на Python оформляется в виде модулей, которые в свою очередь могут быть собраны в пакеты. Модули могут располагаться как в каталогах, так и в ZIP-архивах. Модули могут быть двух типов по своему происхождению: модули, написанные на «чистом» Python, и модули расширения (extension modules), написанные на других языках программирования. Например, в стандартной библиотеке есть «чистый» модуль pickle и его аналог на Си: cPickle. Модуль оформляется в виде отдельного файла, а пакет — в виде отдельного каталога. Подключение модуля к программе осуществляется оператором import. После импорта модуль представлен отдельным объектом, дающим доступ к пространству имён модуля. В ходе выполнения программы модуль можно перезагрузить функцией reload().

# Подключение модуля из стандартной библиотеки

Подключить модуль можно с помощью инструкции import:
```
import os # модуль os для получения текущей директории
os.getcwd() # 'C:\\Python33'
```
Одной инструкцией можно подключить несколько модулей.
```
import time, random
time.time() # 1376047104.056417
random.random() # 0.9874550833306869
```
После импортирования модуля его название становится переменной, через которую можно получить доступ к атрибутам модуля. 
```
import math
math.e # 2.718281828459045
```
если указанный атрибут модуля не будет найден, возбудится исключение AttributeError. А если не удастся найти модуль для импортирования, то ImportError.
```
import notexist
```
# Функция dir()
Встроенная функция dir() используется для получения имён, определённых в модуле.

# Использование псевдонимов
Если название модуля слишком длинное, то для него можно создать псевдоним, с помощью ключевого слова as.
```
import math as m

from math import e, ceil as c
e # 2.718281828459045
c(4.6) # 5
```
Импортируемые атрибуты можно разместить на нескольких строках, если их много:
```
from math import (sin, cos,
          tan, atan)

from позволяет подключить все переменные из модуля. 
from sys import *
```

# Модуль sys

Модуль sys обеспечивает доступ к некоторым переменным и функциям, взаимодействующим с интерпретатором python.

- sys.argv - список аргументов командной строки, передаваемых сценарию Python. sys.argv[0] является именем скрипта (пустой строкой в интерактивной оболочке).

- sys.byteorder - порядок байтов. Будет иметь значение 'big' при порядке следования битов от старшего к младшему, и 'little', если наоборот (младший байт первый).

- sys.builtin_module_names - кортеж строк, содержащий имена всех доступных модулей.

- sys.call_tracing(функция, аргументы) - вызывает функцию с аргументами и включенной трассировкой, в то время как трассировка включена.

- sys.copyright - строка, содержащая авторские права, относящиеся к интерпретатору Python.

- sys._clear_type_cache() - очищает внутренний кэш типа.

- sys._current_frames() - возвращает словарь-отображение идентификатора для каждого потока в верхнем кадре стека в настоящее время в этом потоке в момент вызова функции.

- sys.dllhandle - целое число, определяющее дескриптор DLL Python (Windows).

- sys.exc_info() - возвращает кортеж из трех значений, которые дают информацию об исключенях, обрабатывающихся в данный момент.

-  sys.exec_prefix - каталог установки Python.

- sys.executable - путь к интерпретатору Python.

- sys.exit([arg]) - выход из Python. Возбуждает исключение SystemExit, которое может быть перехвачено.

- sys.flags - флаги командной строки. Атрибуты только для чтения.

- sys.float_info - информация о типе данных float.

- sys.float_repr_style - информация о применении встроенной функции repr() для типа float.

- sys.getdefaultencoding() - возвращает используемую кодировку.

- sys.getdlopenflags() - значения флагов для вызовов dlopen().

- sys.getfilesystemencoding() - возвращает кодировку файловой системы.

- sys.getrefcount(object) - возвращает количество ссылок на объект. Аргумент функции getrefcount - еще одна ссылка на объект.

- sys.getrecursionlimit() - возвращает лимит рекурсии.

- sys.getsizeof(object[, default]) - возвращает размер объекта (в байтах).

- sys.getswitchinterval() - интервал переключения потоков.

- sys.getwindowsversion() - возвращает кортеж, описывающий версию Windows.

- sys.hash_info - информация о параметрах хэширования.

- sys.hexversion - версия python как шестнадцатеричное число (для 3.2.2 final это будет 30202f0).

- sys.implementation - объект, содержащий информацию о запущенном интерпретаторе python.

- sys.int_info - информация о типе int.

- sys.intern(строка) - возвращает интернированную строку.

- sys.last_type, sys.last_value, sys.last_traceback - информация об обрабатываемых исключениях. По смыслу похоже на sys.exc_info().

- sys.maxsize - максимальное значение числа типа Py_ssize_t (2:sup:31 на 32-битных и 263 на 64-битных платформах).

- sys.maxunicode - максимальное число бит для хранения символа Unicode.

- sys.modules - словарь имен загруженных модулей. Изменяем, поэтому можно позабавиться :)

- sys.path - список путей поиска модулей.

- sys.path_importer_cache - словарь-кэш для поиска объектов.

- sys.platform - информация об операционной системе.
```
Linux (2.x and 3.x) 'linux'
Windows 'win32'
Windows/Cygwin  'cygwin'
Mac OS X    'darwin'
OS/2    'os2'
OS/2 EMX    'os2emx'
```
# sys.prefix - папка установки интерпретатора python.

- sys.ps1, sys.ps2 - первичное и вторичное приглашение интерпретатора (определены только если интерпретатор находится в интерактивном режиме). По умолчанию sys.ps1 == ">>> ", а sys.ps2 == "... ".

- sys.dont_write_bytecode - если true, python не будет писать .pyc файлы.

- sys.setdlopenflags(flags) - установить значения флагов для вызовов dlopen().

- sys.setrecursionlimit(предел) - установить максимальную глубину рекурсии.

- sys.setswitchinterval(интервал) - установить интервал переключения потоков.

- sys.settrace(tracefunc) - установить "след" функции.

- sys.stdin - стандартный ввод.

- sys.stdout - стандартный вывод.

- sys.stderr - стандартный поток ошибок.

- sys.__stdin__, sys.__stdout__, sys.__stderr__ - исходные значения потоков ввода, вывода и ошибок.

- sys.tracebacklimit - максимальное число уровней отслеживания.

- sys.version - версия python.

- sys.api_version - версия C API.

- sys.version_info - Кортеж, содержащий пять компонентов номера версии.

- sys.warnoptions - реализация предупреждений.

- sys.winver - номер версии python, использующийся для формирования реестра Windows.


# Модуль os

Модуль os предоставляет множество функций для работы с операционной системой, причём их поведение, как правило, не зависит от ОС, поэтому программы остаются переносимыми. Здесь будут приведены наиболее часто используемые из них.

Будьте внимательны: некоторые функции из этого модуля поддерживаются не всеми ОС.

- os.name - имя операционной системы. Доступные варианты: 'posix', 'nt', 'mac', 'os2', 'ce', 'java'.

- os.environ - словарь переменных окружения. Изменяемый (можно добавлять и удалять переменные окружения).

- os.getlogin() - имя пользователя, вошедшего в терминал (Unix).

- os.getpid() - текущий id процесса.

- os.uname() - информация об ОС. возвращает объект с атрибутами: sysname - имя операционной системы, nodename - имя машины в сети (определяется реализацией), release - релиз, version - версия, machine - идентификатор машины.

- os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True) - проверка доступа к объекту у текущего пользователя. Флаги: os.F_OK - объект существует, os.R_OK - доступен на чтение, os.W_OK - доступен на запись, os.X_OK - доступен на исполнение.

- os.chdir(path) - смена текущей директории.

- os.chmod(path, mode, *, dir_fd=None, follow_symlinks=True) - смена прав доступа к объекту (mode - восьмеричное число).

- os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True) - меняет id владельца и группы (Unix).

- os.getcwd() - текущая рабочая директория.

- os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True) - создаёт жёсткую ссылку.

- os.listdir(path=".") - список файлов и директорий в папке.

- os.mkdir(path, mode=0o777, *, dir_fd=None) - создаёт директорию. OSError, если директория существует.

- os.makedirs(path, mode=0o777, exist_ok=False) - создаёт директорию, создавая при этом промежуточные директории.

- os.remove(path, *, dir_fd=None) - удаляет путь к файлу.

- os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None) - переименовывает файл или директорию из src в dst.

- os.renames(old, new) - переименовывает old в new, создавая промежуточные директории.

- os.replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None) - переименовывает из src в dst с принудительной заменой.

- os.rmdir(path, *, dir_fd=None) - удаляет пустую директорию.

- os.removedirs(path) - удаляет директорию, затем пытается удалить родительские директории, и удаляет их рекурсивно, пока они пусты.

- os.symlink(source, link_name, target_is_directory=False, *, dir_fd=None) - создаёт символическую ссылку на объект.

- os.sync() - записывает все данные на диск (Unix).

- os.truncate(path, length) - обрезает файл до длины length.

- os.utime(path, times=None, *, ns=None, dir_fd=None, follow_symlinks=True) - модификация времени последнего доступа и изменения файла. Либо times - кортеж (время доступа в секундах, время изменения в секундах), либо ns - кортеж (время доступа в наносекундах, время изменения в наносекундах).

- os.walk(top, topdown=True, onerror=None, followlinks=False) - генерация имён файлов в дереве каталогов, сверху вниз (если topdown равен True), либо снизу вверх (если False). Для каждого каталога функция walk возвращает кортеж (путь к каталогу, список каталогов, список файлов).

- os.system(command) - исполняет системную команду.

- os.urandom(n) - n случайных байт. Возможно использование этой функции в криптографических целях.

- os.path - модуль, реализующий некоторые полезные функции на работы с путями.

# Модуль os.path

os.path является вложенным модулем в модуль os, и реализует некоторые полезные функции на работы с путями.

- os.path.abspath(path) - возвращает нормализованный абсолютный путь.

- os.path.basename(path) - базовое имя пути (эквивалентно os.path.split(path)[1]).

- os.path.commonprefix(list) - возвращает самый длинный префикс всех путей в списке.

- os.path.dirname(path) - возвращает имя директории пути path.

- os.path.exists(path) - возвращает True, если path указывает на существующий путь или дескриптор открытого файла.

- os.path.expanduser(path) - заменяет ~ или ~user на домашнюю директорию пользователя.

- os.path.expandvars(path) - возвращает аргумент с подставленными переменными окружения ($name или ${name} заменяются переменной окружения name). Несуществующие имена не заменяет. На Windows также заменяет %name%.

- os.path.getatime(path) - время последнего доступа к файлу, в секундах.

- os.path.getmtime(path) - время последнего изменения файла, в секундах.

- os.path.getctime(path) - время создания файла (Windows), время последнего изменения файла (Unix).

- os.path.getsize(path) - размер файла в байтах.

- os.path.isabs(path) - является ли путь абсолютным.

- os.path.isfile(path) - является ли путь файлом.

- os.path.isdir(path) - является ли путь директорией.

- os.path.islink(path) - является ли путь символической ссылкой.

- os.path.ismount(path) - является ли путь точкой монтирования.

- os.path.join(path1[, path2[, ...]]) - соединяет пути с учётом особенностей операционной системы.

- os.path.normcase(path) - нормализует регистр пути (на файловых системах, не учитывающих регистр, приводит путь к нижнему регистру).

- os.path.normpath(path) - нормализует путь, убирая избыточные разделители и ссылки на предыдущие директории. На Windows преобразует прямые слеши в обратные.

- os.path.realpath(path) - возвращает канонический путь, убирая все символические ссылки (если они поддерживаются).

- os.path.relpath(path, start=None) - вычисляет путь относительно директории start (по умолчанию - относительно текущей директории).

- os.path.samefile(path1, path2) - указывают ли path1 и path2 на один и тот же файл или директорию.

- os.path.sameopenfile(fp1, fp2) - указывают ли дескрипторы fp1 и fp2 на один и тот же открытый файл.

- os.path.split(path) - разбивает путь на кортеж (голова, хвост), где хвост - последний компонент пути, а голова - всё остальное. Хвост никогда не начинается со слеша (если путь заканчивается слешем, то хвост пустой). Если слешей в пути нет, то пустой будет голова.

- os.path.splitdrive(path) - разбивает путь на пару (привод, хвост).

- os.path.splitext(path) - разбивает путь на пару (root, ext), где ext начинается с точки и содержит не более одной точки.

- os.path.supports_unicode_filenames - поддерживает ли файловая система Unicode.
```
import os.path

os.path.join("/tmp/1", "temp.file")  # конкатенация путей '/tmp/1/temp.file'
os.path.dirname("/tmp/1/temp.file")  # имя каталога по заданному полному пути '/tmp/1'
os.path.basename("/tmp/1/temp.file")  # имя файла по заданному полному пути 'temp.file'
os.path.normpath("/tmp//2/../1/temp.file")  # нормализация пути '/tmp/1/temp.file'
os.path.exists("/tmp/1/temp.file")  # существует ли путь? False

```
# функция eval
В Python есть функция eval, которая в качестве аргумента принимает строку и воспроизводит ее как выражение Python. Для того, чтобы показать что это значит:
```
>>> r = eval('1+2')
>>> r
3
>>> type(r)
<type 'int'>
```
Результат выражения r = eval('1+2') тот же самый, если бы мы записали r = 1+2:
```
>>> r = 1+2
>>> r
3
>>> type(r)
<type 'int'>
```
В следующих примерах показано, как функция eval возвращает число, строку, список, кортеж и так далее.
```
>>> r = eval('2.5')
>>> r
2.5
>>> type(r)
<type 'float'>

>>> r = eval('"math  programming"')
>>> r
'math  programming'
>>> type(r)
<type 'str'>

>>> r = eval('[1, 6, 7.5]')
>>> r
[1, 6, 7.5]
>>> type(r)
<type 'list'>

>>> r = eval('(-1, 1)')
>>> r
(-1,  1)
>>> type(r)
<type 'tuple'>

>>> from  math import sqrt
>>> r = eval('sqrt(2)')
>>> r
1.4142135623730951
>>> type(r)
<type 'float'>
```
raw_input возвращает объект типа string. А функция eval такие объекты принимает и выполняет. 
напишем маленькую программу, которая принимает и складывает два значения. Значениями может быть все, что угодно, к чему можно применять операцию сложения: целые и дробные числа, строки, списки и так далее. Поскольку мы не знаем, что именно пользователь складывает, то здесь и будет удобно использовать eval:
```
i1 = eval(raw_input('Give  input: '))
i2 = eval(raw_input('Give  input: '))
r = i1 + i2
print '%s + %s becomes %s\nwith value %s' % \
(type(i1), type(i2), type(r), r)
```
Добавление друг к другу строк происходит только, если они введены в кавычках. Естественно, что объекты разных типов не могут суммироваться, так же, как это происходит и в Python. Отсюда видно первое применение функции eval — обработка строк «на лету», что очень удобно при разработке программ. 
Другой пример представляет собой возможность ввода часто изменяющегося кода — обрабатываемых математических формул:
```
formula = raw_input('Give a formula involving x: ')
x = eval(raw_input('Give x: '))
from math import *     #  теперь доступны все функции из math
result = eval(formula)
print '%s for x=%g yields %g' % (formula, x, result)
```

# функция exec

позволяет выполнять (execute) любой код на Python, не только выражения:
```
formula = raw_input('Write a formula involving x: ')
code = """
def f(x):
    return %s
""" % formula
exec(code)
```
Если, отвечая на вопрос, мы введем, например, sin(x)*cos(3*x) + x**2, то formula примет его и далее будет использована строкой code, которая будет работать как если бы:
```
"""
def f(x):
    return sin(x)*cos(3*x) +  x**2
"""
```
но при этом формула может быть любой, которую мы захотим. Далее, exec выполняет все, что записано в code, как если бы мы записали все это сами. Таким образом, мы можем превратить любую данную пользователем функцию в функцию Python!


Добавим к предыдущему коду цикл while, позволяющий запускать программу множество раз, в зависимости от выбора пользователя:
```
x = 0
while x is not None:
    x = eval(raw_input('Give x (None to quit): '))
    if x is not None:
        print 'f(%g)=%g' % (x, f(x))
```

# Python. Использование модулей

# Создание своего модуля на Python
Создадим файл mymodule.py, в которой определим какие-нибудь функции:
```
def hello():
    print('Hello, world!')
def fib(n):
    a = b = 1
    for i in range(n - 2):
        a, b = b, a + b
    return b
```
Теперь в этой же папке создадим другой файл, например, main.py:
```
import mymodule
mymodule.hello()
print(mymodule.fib(10))

```
# Создание своего модуля на Python: прибыль от вклада
Классическая формула для определения прибыли по вкладу в банке выглядит так:

A = A_0\Bigl(1 + \frac{p}{360\cdot100}\Bigr)^n, 
где A_0 начальная сумма денег, A — сумма после n дней с процентом годовых p. Выражение, таким образом, включает четыре параметра, определим три оставшихся:

A_0 = A\Bigl(1 + \frac{p}{360\cdot100}\Bigr)^{-n},  
n = \frac{ln(\frac{A}{A_0})}{ln(1 + \frac{p}{360\cdot100})},    
p = 360 \cdot 100 \Bigl(\Bigl(\frac{A}{A_0}\Bigr)^\frac{1}{n} - 1\Bigr).   

Далее мы представили формулы в виде четырех функций:
```
from math import log as ln

def present_amount(A0, p, n):
    return A0*(1 + p/(360.0*100))**n

def initial_amount(A,  p,  n):
    return A*(1 + p/(360.0*100))**(-n)

def days(A0,  A,  p):
    return ln(A/A0)/ln(1 + p/(360.0*100))

def annual_rate(A0, A, n):
    return 360*100*((A/A0)**(1.0/n) - 1)
```
Теперь мы хотим сделать эти функции доступными из модуля, который мы, скажем, назовем interest (прибыль), так чтобы мы могли импортировать эти функции и вычислять требуемые значения. Например, так 1.py:
```
from interest import days
A0 = 1; A = 2;  p = 5
n = days(A0, A, p)
years =  n/365.0
print 'Money has doubled after %.1f  years' % years
```
# Как создать модуль

### Собираем функции в файле модуля

Для того, чтобы сделать модуль для четырех функций present_amount, initial_amount, days и annual_rate, мы просто открываем новый файл и копируем программный код для всех четырех функций. И тут же наш файл превращается в модуль Python с тем именем, под которым мы его сохранили. Файл должен обязательно иметь расширение .py, но именем модуля является его основная часть. В нашем случае файл называется interest.py, а модуль поэтому будет вызываться как interest. Для того, чтобы использовать, например, функцию annual_rate мы просто пишем в программе, где она нужна:
```
from interest import annual_rate
```
Также доступны и все остальные способы. Например, конструкция
```
from interest import *
```
импортирует все четыре функции. Можем мы и просто импортировать сам модуль:
```
import interest
```
и вызывать функции с приставками, например, interest.annual_rate. Стоит сказать, что модуль и программу, использующую его, надо размещать в одной папке. 

# Test block

Рекомендуется в файле модуля определять только сами функции, без инструкций, выходящих за их пределы. Это условие желательно выполнять, чтобы при импортировании модуля не происходило ненужных вычислений. Однако, Python позволяет конструкцию, которая дает возможность использовать файл программы и как модуль, содержащий описания функций и как исполняющую программу. Такая двухсторонняя магия заключается в добавлении следующего if-блока:
```
if __name__ == '__main__':
    <block of statements>
```
Имена с двумя нижними подчеркиваниями являются служебными. Переменная __name__ автоматически определяется в любом модуле как имя модуля, если он импортируется в другую программу или как строка '__main__', если файл модуля запущен как программа. Это подразумевает, что в указанной выше конструкции block of statements выполняются тогда и только тогда, когда мы запускаем файл модуля как самостоятельную программу. И, собственно, этот block of statements и называют test block.

Зачастую, когда модуль создается из обычной программы, оригинальная программа используется в качестве test block. Новый файл модуля работает как старая программа, но с новой возможностью быть импортированной в другую программу. 

Давайте, напишем маленькую программу, которая проверит способности нашего модуля interest. Идея в том, что мы присвоим четырем параметрам приемлемые значения и проверим, что дают остальные, то есть правильно ли мы нашли и записали функции interest0.py:

```
if __name__ == '__main__':
    A = 2.2133983053266699
    A0 = 2.0
    p = 5
    n = 730
    print 'A=%g (%g)\nA0=%g (%.1f)\nn=%d (%d)\np=%g (%.1f)' % \
          (present_amount(A0, p, n), A,
           initial_amount(A, p, n), A0,
           days(A0, A, p), n,
           annual_rate(A0, A, n), p)
```
Этот блок мы вставляем после записанных ранее функций, а далее сохранив, видим, что наш модуль может работать и как программа:

```
interest0.py
A=2.2134 (2.2134)
A0=2 (2.0)
n=730 (730)
p=5 (5.0)
```
И здесь мы видим, что значения после знака равенства и в скобках совпадают. Значит модуль и в качестве программы работает правильно. Теперь посмотрим как он исполняет свои прямые обязанности. Для этого в интерактивном режиме Python импортируем из него какую-нибудь функцию и рассчитаем с помощью нее значение:
```
>>> from interest import present_amount
>>> present_amount(2, 5, 730)
2.2133983053266699
```
Теперь у нас есть все доказательства, что файл interest.py верно работает и как программа, и как модуль.

## Гибкий test block

Хорошей практикой программирования является возможность test block осуществлять одно или более из трех действий: 

1. давать информацию о том как модуль или программа используются, 
2. проверять верно ли работают функции модуля, 
3. позволять взаимодействие с пользователем.

Вместо того, чтобы иметь множество инструкций в тестовом блоке, гораздо лучше собирать их в отдельные функции, которые затем в нем вызываются. 

Существует соглашение давать таким тестовым функциям имена, начинающиеся с подчеркивания, поскольку такие имена не импортируется в другие программы во время действия инструкции from module import * (это и естественно, ведь за пределами модуля они нам обычно не нужны). В нашем примере мы соберем все проверяющие инструкции в отдельной функции _verify:

1. interest1.py
```
def _verify():
    A = 2.2133983053266699; A0 = 2.0; p = 5; n = 730
    A_computed = present_amount(A0, p, n)
    A0_computed = initial_amount(A, p, n)
    n_computed = days(A0, A, p)
    p_computed = annual_rate(A0, A, n)
    print 'A=%g (%g)\nA0=%g (%.1f)\nn=%d (%d)\np=%g (%.1f)' % \
          (A_computed, A, A0_computed, A0,
           n_computed, n, p_computed, p)
```
Мы можем создать специальный аргумент командной строки verify, с помощью которого запускается проверка. В test block добавляем соответствующее условие:
```
if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] == 'verify':
        _verify()
```
Чтобы сделать программу полезной, сделаем так, что в командной строке можно вводить три параметра, а программа рассчитывает остающийся.

После того как переменные введены в командной строке, мы можем взять этот текст как код Python. А сделать это несложно 2:

2. interest2.py

```
init_code = ''
for statement in sys.argv[1:]:
    init_code += statement + '\n'
exec(init_code)
```
Например, для запуска с A0=2 A=1 n=1095 в command line, init_code становится строкой

```
A0=2
A=1
n=1095
```
Особо отметим, что здесь в командной строке нельзя ставить пробелы вокруг выражений, иначе это воспримется как три разных аргумента и возникнет исключение SyntaxError в exec(init_code). Для того, чтобы рассказать пользователю о потенциальной ошибке, поместим (init_code) в блок try-except:
```
try:
    exec(init_code)
except SyntaxError, e:
    print e
    print init_code
    sys.exit(1)
```
Может случиться, что пользователь присвоил значение параметру с неверным именем или вовсе его забыл. В таких случаях мы вызываем функцию с не инициализированными аргументами, что, как известно, приводит к исключению NameError, в то время как неверное значение возбудит ValueError. Так у нас выросла большая, но нужная проверяющая функция 3:
```
def _compute_missing_parameter(init_code):
    try:
        exec(init_code)
    except SyntaxError, e:
        print e
        print init_code
        sys.exit(1)
    # find missing parameter:
    try:
        if 'A=' not in init_code:
            print 'A =', present_amount(A0, p, n)
        elif 'A0=' not in init_code:
            print 'A0 =', initial_amount(A, p, n)
        elif 'n=' not in init_code:
            print 'n =', days(A0, A , p)
        elif 'p=' not in init_code:
            print 'p =', annual_rate(A0, A, n)
    except NameError, e:
        print e
        sys.exit(1)
    except ValueError:
        print 'Illegal values in input:', init_code
        sys.exit(1)
```

Если пользователь вообще не вводит аргументов командной строки (что скорее всего означает первый запуск), выводится инструкция об использовании (usage) программы. Далее, если вводится один аргумент и это строка 'verify', то мы запускаем проверку. В оставшихся случаях мы собственно обрабатываем подаваемые значения. 

```
_filename = sys.argv[0]
_usage = """
Usage: %s A=10 p=5 n=730
Program computes and prints the 4th parameter'
(A, A0, p, or n)""" % _filename

if __name__ == '__main__':
    if len(sys.argv) == 1:
        print _usage
    elif len(sys.argv) == 2 and sys.argv[1] == 'verify':
        _verify()
    else:
        init_code = ''
        for statement in sys.argv[1:]:
            init_code += statement + '\n'
        #вообще более элегантно:
        #init_code = '; '.join(sys.argv[1:])
        _compute_missing_parameter(init_code)
```
Также хорошо привычкой является включать строки документации в самом начале модуля. Эти doc strings обычно поясняют цель модуля и как его использовать. Ими можно пользоваться и не открывая файл модуля, их можно вывести, например, с помощью инструкции print имя_модуля.__doc__.

```
"""
Module for computing with interest rates.
Symbols: A is present amount, A0 is initial amount,
n counts days, and p is the interest rate per year.

Given three of these parameters, the fourth can be
computed as follows:

    A  = present_amount(A0, p, n)
    A0 = initial_amount(A, p, n)
    n  = days(A0, A, p)
    p  = annual_rate(A0, A, n)
"""

import sys
_filename = sys.argv[0]
_usage = """
Usage: %s A=10 p=5 n=730
Program computes and prints the 4th parameter'
(A, A0, p, or n)""" % _filename

from math import log as ln

def present_amount(A0, p, n):
    return A0*(1 + p/(360.0*100))**n

def initial_amount(A, p, n):
    return A*(1 + p/(360.0*100))**(-n)

def days(A0, A, p):
    return ln(A/A0)/ln(1 + p/(360.0*100))

def annual_rate(A0, A, n):
    return 360*100*((A/A0)**(1.0/n) - 1)

def _verify():
    A = 2.2133983053266699; A0 = 2.0; p = 5; n = 730
    A_computed = present_amount(A0, p, n)
    A0_computed = initial_amount(A, p, n)
    n_computed = days(A0, A, p)
    p_computed = annual_rate(A0, A, n)
    print 'A=%g (%g)\nA0=%g (%.1f)\nn=%d (%d)\np=%g (%.1f)' % \
          (A_computed, A, A0_computed, A0,
           n_computed, n, p_computed, p)

def _compute_missing_parameter(init_code):
    try:
        exec(init_code)
    except SyntaxError, e:
        print e
        print init_code
        sys.exit(1)

    try:
        if 'A=' not in init_code:
            print 'A =', present_amount(A0, p, n)
        elif 'A0=' not in init_code:
            print 'A0 =', initial_amount(A, p, n)
        elif 'n=' not in init_code:
            print 'n =', days(A0, A , p)
        elif 'p=' not in init_code:
            print 'p =', annual_rate(A0, A, n)
    except NameError, e:
        print e
        sys.exit(1)
    except ValueError:
        print 'Illegal values in input:', init_code
        sys.exit(1)

if __name__ == '__main__':
    if len(sys.argv) == 1:
        print _usage
    elif len(sys.argv) == 2 and sys.argv[1] == 'verify':
        _verify()
    else:
        init_code = ''
        for statement in sys.argv[1:]:
            init_code += statement + '\n'
        _compute_missing_parameter(init_code)
```
# Использование модулей
Давайте посмотрим как дальше использовать модуль interest в программах. Для этого мы создадим новый файл test.py, выполняющий некоторые расчеты:

```
from interest import days
# сколько лет потребуется для удвоения суммы вклада
# если процент p=1,2,3,...14?
for p in range(1,  15):
    years = days(1, 2, p)/365.0
    print 'With p=%d%% it takes %.1f years to double the amount' \
    % (p, years)
```
Функция dir() создает список всех определенных во время сеанса имен, включая импортируемые имена переменных и функций. Вызов dir(m) даст нам все имена, определенные в модуле m. Для начала запустим IDLE и вызовем просто dir()

```
>>> dir()
['__builtins__', '__doc__', '__name__', '__package__']
```
Эти переменные, как видно по подчеркиваниям, являются служебными и всегда определены. Если же импортировать:

```
>>> from interest import *
>>> dir()
[ ..., 'annual_rate', 'days', 'initial_amount', 'present_amount', 'ln', 'sys']
```
мы видим, что наши четыре функции и все доступные сопутствующие импортировались. Можно заметить, что имена, определенные нами с нижнего подчеркивания, в списке отсутствуют. Это важное следствие — ненужные имена не загрязняют «пространство имен» и уменьшается возможность ошибок из-за совпадения имен, что может случиться при импортировании через *. Теперь заглянем в сам модуль:

```
>>> import interest
>>> dir(interest)
['__builtins__', '__doc__', '__file__', '__name__', '__package__', '_compute_missing_parameter', '_filename',
'_usage', '_verify', 'annual_rate', 'days', 'initial_amount', 'ln', 'present_amount', 'sys']
```
И здесь мы видим и скрытые раньше локальные имена с префиксом. И, вообще говоря, мы их вполне можем использовать самостоятельно вызывая:

```
>>> interest._verify()
A=2.2134 (2.2134)
A0=2 (2.0)
n=730 (730)
p=5 (5.0)
>>> interest._filename
```
программа test.py работает так долго, как долго она находится в одной папке с модулем interest.py. Однако, если она заблудится, то мы получим ошибку:

```
test.py
Traceback (most recent call last):
   File  "tmp.py", line 1, in  <module>
      from  interest  import  days
ImportError: No module named interest
```
Программа не может найти модуль. Python по своему обыкновению ищет модуль среди папок, указанных в списке sys.path. Посмотрим содержимое этого списка:

```
>>> import sys
>>> print sys.path
```
Кроме наиболее простого способа — размещения модуля в одной папке с программой, можно в программе и прописать путь до папки:

```
modulefolder = '../../pymodules'
sys.path.insert(0, modulefolder)
```
Python ищет имена в sys.path именно в той последовательности, в которой они расположены в списке. Поэтому и путь мы ставим нулевым элементом.

Синтаксис from importable import * используется для импортирования всех объектов из модуля (или из всех модулей пакета) - это могут быть сотни имен. В случае from os.path import * будет импортировано почти 40 имен, включая имена dirname, exists и split. 

Например, если записать инструкцию from os.path import dirname, мы получим удобную возможность вызывать функцию dirname(), не указывая полное квалифицированное имя. Но если ниже в нашем программном коде будет встречена инструкция dirname = ".", то после ее выполнения ссылка на объект dirname будет указывать уже не на функцию dirname(), а на строку ".". Поэтому, если мы попытаемся вызвать функцию dirname(), мы получим исключение TypeError, потому что теперь имя dirname ссылается на строку, а не на вызываемый объект. 

Ввиду того, что синтаксис import * потенциально опасен появлением конфликтов имен, некоторые коллективы разработчиков вырабатывают свои правила, устанавливающие, что в их разработках может использоваться только синтаксис import importable. Однако некоторые крупные пакеты, в частности библиотеки GUI (Graphical User Interface - графический интерфейс пользователя), нередко импортируются таким способом, потому что они включают огромное число функций и классов (собственных типов данных), для которых было бы слишком утомительно вводить вручную полные имена. 

Возникает естественный вопрос - как интерпретатор узнает, где искать импортируемые модули и пакеты? Встроенный модуль sys имеет список с именем sys.path, в котором хранится перечень каталогов, составляющих путь поиска Python. Первый каталог в этом списке — это каталог, где находится сама программа, даже если она вызывается из другого каталога. Далее в списке находятся пути к каталогам из переменной окружения PYTHONPATH, если она определена. И в конце списка находятся пути к каталогам стандартной библиотеки языка Python - они определяются на этапе установки Python. 

Когда модуль импортируется впервые, если он не является встроенным, интерпретатор пытается отыскать его поочередно в каждом из каталогов, перечисленных в списке sys.path. Как следствие этого, если мы создаем модуль или программу, имя которого совпадает с именем библиотечного модуля, наш модуль будет найден первым, что неизбежно будет приводить к проблемам. Чтобы избежать этого, никогда не создавайте программы или модули, имена которых совпадают с именами модулей или каталогов верхнего уровня в библиотеке, если только вы не пытаетесь подставить свою собственную реализацию и ваше переопределение преднамеренно. (Модулем верхнего уровня называется файл .ру, который находится в одном из каталогов, включенных в путь поиска Python, а не в каком-нибудь подкаталоге, вложенном в один из этих каталогов.) Например, в системе Windows в путь поиска Python обычно включается каталог с именем C:\Python30\Lib, поэтому на этой платформе мы не должны создавать модуль с именем ЫЬ.ру, так же как модуль, имя которого совпадает с именем любого модуля из каталога C:\Python30\Lib. 

Один из способов быстро проверить, используется ли то или иное имя модуля, состоит в том, чтобы попытаться импортировать модуль. Сделать это можно в консоли, вызвав интерпретатор с ключом -с («execute code» - выполнить программный код), за которым следует указать инструкцию import. Например, если необходимо проверить, существует ли модуль с именем Music, ру (или каталог верхнего уровня Music в пути поиска Python), можно ввести в консоли следующую команду: 
```
python -с "import Music" 
```
Если в ответ будет получено исключение ImportError, можно быть уверенным, что модуль или каталог верхнего уровня с таким именем не используется; любой другой вывод (или его отсутствие) означает наличие такого имени. К сожалению, такой прием не дает полной гарантии, что впоследствии с этим именем не будет возникать никаких проблем, поскольку позднее мы можем установить пакет или модуль, созданный сторонним разработчиком, имеющий такое же имя, хотя на практике такая проблема возникает достаточно редко. Например, если мы создадим модуль os.py, он будет конфликтовать с библиотечным модулем os. Но если мы создадим модуль path.py, то никаких проблем возникать не будет, поскольку этот модуль пришлось бы импортировать как модуль path, тогда как библиотечный модуль должен импортироваться как os.path. В этой книге имена файлов наших собственных модулей всегда будут начинаться с символа верхнего регистра; это позволит избежать конфликтов имен (по крайней мере в UNIX), потому что имена файлов библиотечных модулей состоят исключительно из символов нижнего регистра. Программа может импортировать некоторые модули, которые в свою очередь импортируют другие модули, включая те, что уже были импортированы. Это не является проблемой. Всякий раз, когда выполняется попытка импортировать модуль, интерпретатор Python сначала проверяет - не был ли импортирован требуемый модуль ранее. Если модуль еще не был импортирован, Python выполняет скомпилированный байт-код модуля, создавая тем самым переменные, функции и другие объекты модуля, после чего добавляет во внутреннюю структуру запись о том, что модуль был импортирован. При любых  последующих попытках импортировать этот модуль интерпретатор будет обнаруживать, что модуль уже импортирован и не будет выполнять никаких действий.

Когда интерпретатору требуется скомпилированный байт-код модуля, он генерирует его автоматически - этим Python отличается от таких языков программирования, как Java, где компилирование в байт-код должно выполняться явно. Сначала интерпретатор попытается отыскать файл, имя которого совпадает с именем файла, имеющего расширение .ру, но имеющий расширение .руо - это оптимизированный байт-код скомпилированной версии модуля. Если файл с расширением .руо не будет найден (или он более старый, чем файл с расширением .ру), интерпретатор попытается отыскать одноименный файл с расширением .рус - это неоптимизированный байт-код скомпилированной версии модуля. Если интерпретатор обнаружит актуальную скомпилированную версию модуля, он загрузит ее; в противном случае Python загрузит файл с расширением .ру и скомпилирует его в байт-код. 

В любом случае интерпретатор загрузит в память модуль в виде скомпилированного байт-кода. Если интерпретатор выполнил компиляцию файла с расширением .ру, он сохранит скомпилированную версию в одноименном файле с расширением .рус (или .руо, если интерпретатор был запущен с ключом командной строки -О, или если в переменной окружения PYTH0N0PTIMIZE установлено значение 0), при этом каталог должен быть доступен для записи. Сохранения байт-кода можно избежать, если запускать интерпретатор с ключом командной строки -В или установив переменную окружения PYTH0ND0NTWRITEBYTEC0DE. 

Использование файлов со скомпилированным байт-кодом ускоряет запуск программы, поскольку интерпретатору остается только загрузить и выполнить программный код, минуя этап компиляции (и сохранения, если это возможно), хотя сама скорость работы программы от этого не зависит. При установке Python компиляция модулей стандартной библиотеки в байт-код обычно является частью процесса установки. 
# Пакеты 
Пакет - это простой каталог, содержащий множество модулей и файл с именем init .ру. Например, допустим, что у нас имеется некоторое множество файлов модулей с именами Crash.py Prettier.py Slot.py, в каждом из которых имеются функции и т. д. Мы могли бы сохранить все эти модули в одном каталоге с программой, но в крупных программных продуктах, использующих массу собственных модулей, модули лучше хранить отдельно. Поместив их в свой собственный подкаталог, например Game, их можно хранить все вместе. 
А если поместить в каталог Game пустой файл __init__ .ру, этот каталог превратится в пакет: 
```
Game/ 
__init__ .ру 

Crash.py Prettier.py Slot.py
```
Пока каталог Game является подкаталогом каталога с программой или находится в пути поиска Python, мы будем иметь возможность импортировать любой из этих модулей и использовать их. Мы должны сделать все возможное, чтобы гарантировать несовпадение имени нашего модуля верхнего уровня (Graphics) с каким-либо из имен верхнего уровня в стандартной библиотеке- с целью избежать конфликтов имен. (В системе UNIX это легко обеспечить, достаточно лишь использовать в качестве первого символа имени символ верхнего регистра, так как в именах модулей стандартной библиотеки используются только символы нижнего регистра.) Ниже показано, как импортировать и использовать наши модули: 
```
import Game.Prettier

Game.Prettier.pret(") 
```
В небольших программах некоторые программисты предпочитают использовать более короткие имена, и язык Python позволяет делать это двумя, немного отличающимися способами. 
```
import Game.Prettier as Pret 

```
Здесь мы импортировали модуль Prettier из пакета Game и сообщили интерпретатору, что вместо полного квалифицированного имени Game.Prettier хотим использовать более короткое имя Pret. 
```
from Game import Prettier 

```
Этот фрагмент программного кода напрямую импортирует модуль Prettier из пакета Game. Данная синтаксическая конструкция (import . . . from) обеспечивает непосредственный доступ к модулю Prettier. 
Мы не обязаны использовать в нашем программном коде оригинальные имена модулей. Например: 
```
from Game import Prettier as pict 

```
В некоторых ситуациях бывает удобно загружать все модули пакета одной инструкцией. Для этого необходимо отредактировать файл __init__ .py пакета, записав в него инструкцию, которая указывала бы, какие модули должны загружаться. Эта инструкция должна присваивать список с именами модулей специальной переменной all . 

Например, ниже приводится необходимая строка для файла Game/__init__.py:
``` 
all = ['Crash','Prettier','Slot'] 
```
Этим ограничивается необходимое содержимое файла __init__ .ру, помимо этого, мы можем поместить в него любой программный код, какой только пожелаем. Теперь мы можем использовать другую разновидность инструкции import: 
```
from Game import * 

```
Синтаксис from package import * напрямую импортирует все имена модулей, упомянутые в списке all . 
этот синтаксис может применяться и к модулям, то есть from module import *, в этом случае будут импортированы все функции, переменные и другие объекты, определяемые модулем (за исключением тех, чьи имена начинаются с символа подчеркивания). При необходимости точно указать, что должно быть импортировано при использовании синтаксической конструкции from module import *, мы можем определить список all непосредственно в модуле; в этом случае инструкция from module import * будет импортировать только те объекты, имена которых присутствуют в списке all . 

Python позволяет создавать столько уровней вложенности пакетов, сколько нам заблагорассудится. То есть мы можем поместить в каталог Game подкаталог, скажем, Vector, с файлами модулей Енутри него Eps.py и Svg.py: 
```
Game/__init__ .py 
Bmp.py Jpeg.py Png.py Tiff.py Vector/ __init__.py Eps.py Svg.py Xpm.py 
```
Чтобы каталог Vector превратился в пакет, в него необходимо поместить файл __init__ .py, который, как уже говорилось, может быть пустым или определять список all для обеспечения удобства тем программистам, которые предпочтут использовать инструкцию импортирования 
```
from Game.Vector import *
```
Для доступа к вложенному пакету мы можем использовать обычный синтаксис, который использовали ранее: 
```
import Game.Vector.Eps 

```
Полные квалифицированные имена могут оказаться слишком длинными, поэтому некоторые программисты пытаются привести иерархию модулей к плоскому виду, чтобы избежать необходимости вручную вводить такие имена: 
```
import Game.Vector.Svg as Svg 

```